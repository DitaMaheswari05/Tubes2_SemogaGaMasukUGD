package recipeFinder

import (
	"container/list"
	"sort"
	"strings"
	"sync"
)

type PathExploration struct {
	Path           map[string]RecipeStep  // Current path from target toward base
	IncompletePath map[string]bool        // Elements in path that aren't base elements yet
	Queue          *list.List             // BFS queue for this path
	SearchSteps    []SearchStep           // Visualization steps for this path
	NodeCount      int                    // Nodes visited in this path
}

// Multi-recipe BFS that works in reverse (target → base) with multithreading
func ReversedMultiPathBFSParallel(targetName string, graph IndexedGraph, maxPaths int, numWorkers int) ([]ProductToIngredients, []SearchStep, int) {
	targetID := graph.NameToID[targetName]

	// Track complete paths (each is a separate recipe tree)
	var completePaths []ProductToIngredients
	pathHashes := make(map[string]bool)
	
	// Use mutex to protect shared resources
	var pathsMutex sync.Mutex
	var totalNodesMutex sync.Mutex
	var explorationsMutex sync.Mutex

	// Track all search steps for visualization
	allSearchSteps := []SearchStep{}
	totalNodes := 0

	// We'll need a reverse graph (product → ingredient combinations)
	// This gives us all ways to create an element
	reverseGraph := buildReverseGraph(graph)

	// Start with initial exploration from target
	initialExploration := PathExploration{
		Path:           make(map[string]RecipeStep),
		IncompletePath: map[string]bool{targetName: true},
		Queue:          list.New(),
		SearchSteps:    []SearchStep{},
		NodeCount:      0,
	}

	// Add target to queue
	initialExploration.Queue.PushBack(targetID)

	// Initialize search steps
	initialExploration.SearchSteps = append(initialExploration.SearchSteps, SearchStep{
		CurrentID:       -1,
		CurrentName:     "",
		QueueIDs:        []int{targetID},
		QueueNames:      []string{targetName},
		SeenIDs:         []int{},
		SeenNames:       []string{},
		DiscoveredEdges: make(map[int]struct{ ParentID, PartnerID int }),
		DiscoveredNames: make(map[string]struct{ A, B string }),
		StepNumber:      0,
		FoundTarget:     false,
	})

	// All active path explorations
	activeExplorations := []PathExploration{initialExploration}

	// Channel for workers to get explorations
	explorationsQueue := make(chan PathExploration, maxPaths*3)
	
	// Channel for completed paths
	completedPaths := make(chan struct {
		path        map[string]RecipeStep
		searchSteps []SearchStep
		nodeCount   int
	}, maxPaths)
	
	// Channel to signal workers to stop
	done := make(chan bool)
	
	// Add initial exploration to the queue
	explorationsQueue <- initialExploration

	// Launch worker goroutines
	var wg sync.WaitGroup
	wg.Add(numWorkers)
	
	// Track if we have enough paths
	enoughPaths := false
	var enoughPathsMutex sync.Mutex

	// Worker function
	worker := func(workerId int) {
		defer wg.Done()
		
		for {
			// Check if we should stop
			select {
			case <-done:
				return
			default:
				// Continue processing
			}
			
			// Get next exploration or wait if none available
			var currentExploration PathExploration
			select {
			case currentExploration = <-explorationsQueue:
				// Got an exploration to process
			case <-done:
				return
			}

			// Process the exploration until it's complete or needs to branch
			processExploration(
				currentExploration, 
				reverseGraph, 
				graph, 
				&completedPaths, 
				&explorationsQueue, 
				&enoughPaths,
				&enoughPathsMutex,
				maxPaths,
			)
		}
	}

	// Start workers
	for i := 0; i < numWorkers; i++ {
		go worker(i)
	}

	// Collector goroutine to gather results
	go func() {
		for completedPath := range completedPaths {
			pathsMutex.Lock()
			
			// Check if this path hash is unique
			pathHash := createPathHash(completedPath.path)
			isUnique := !pathHashes[pathHash]
			
			if isUnique {
				pathHashes[pathHash] = true
				completePaths = append(completePaths, completedPath.path)
				allSearchSteps = append(allSearchSteps, completedPath.searchSteps...)
				
				// Signal to stop if we have enough paths
				if len(completePaths) >= maxPaths {
					enoughPathsMutex.Lock()
					enoughPaths = true
					enoughPathsMutex.Unlock()
					
					// Signal all workers to stop
					close(done)
					close(completedPaths)
				}
			}
			
			// Update total nodes
			totalNodesMutex.Lock()
			totalNodes += completedPath.nodeCount
			totalNodesMutex.Unlock()
			
			pathsMutex.Unlock()
		}
	}()

	// Wait for all workers to finish
	wg.Wait()
	
	// Clean up if not already closed
	select {
	case <-done:
		// Already closed
	default:
		close(done)
		close(completedPaths)
	}

	return completePaths, allSearchSteps, totalNodes
}

// Helper function to process a single exploration
func processExploration(
	currentExploration PathExploration,
	reverseGraph map[int][]struct{ InputA, InputB int },
	graph IndexedGraph,
	completedPaths *chan struct{path map[string]RecipeStep; searchSteps []SearchStep; nodeCount int},
	explorationsQueue *chan PathExploration,
	enoughPaths *bool,
	enoughPathsMutex *sync.Mutex,
	maxPaths int,
) {
	localSteps := make([]SearchStep, 0, 100)
	localNodeCount := 0
	
	// Continue BFS on this path until it's complete or we need to branch
	for currentExploration.Queue.Len() > 0 {
		// Check if we have enough paths globally
		enoughPathsMutex.Lock()
		if *enoughPaths {
			enoughPathsMutex.Unlock()
			return
		}
		enoughPathsMutex.Unlock()
		
		// Get next element to explore
		front := currentExploration.Queue.Front()
		curID := currentExploration.Queue.Remove(front).(int)
		curName := graph.IDToName[curID]
		
		currentExploration.NodeCount++
		localNodeCount++
		
		// Record search step
		step := SearchStep{
			CurrentID:   curID,
			CurrentName: curName,
			QueueIDs:    queueToSlice(currentExploration.Queue),
			QueueNames:  queueToNameSlice(currentExploration.Queue, graph),
			// Other visualization fields...
			StepNumber:  currentExploration.NodeCount,
			FoundTarget: false,  // Not relevant in reverse search
		}
		currentExploration.SearchSteps = append(currentExploration.SearchSteps, step)
		localSteps = append(localSteps, step)
		
		// Skip if this is a base element
		if isBaseElement(curName) {
			// Remove from incomplete path
			delete(currentExploration.IncompletePath, curName)
			continue
		}
		
		// Get all ways to create this element
		recipes := reverseGraph[curID]
		
		// Check if we need to branch the path
		if len(recipes) > 1 {
			// First recipe continues in this exploration
			firstRecipe := recipes[0]
			
			// Add recipe to current path
			currentExploration.Path[curName] = RecipeStep{
				Combo: IngredientCombo{
					A: graph.IDToName[firstRecipe.InputA],
					B: graph.IDToName[firstRecipe.InputB],
				},
			}
			
			// Add ingredient elements to incomplete path
			ingredientA := graph.IDToName[firstRecipe.InputA]
			ingredientB := graph.IDToName[firstRecipe.InputB]
			
			// Remove current from incomplete, add ingredients if not base
			delete(currentExploration.IncompletePath, curName)
			if !isBaseElement(ingredientA) {
				currentExploration.IncompletePath[ingredientA] = true
				currentExploration.Queue.PushBack(firstRecipe.InputA)
			}
			
			if !isBaseElement(ingredientB) {
				currentExploration.IncompletePath[ingredientB] = true
				currentExploration.Queue.PushBack(firstRecipe.InputB)
			}
			
			// Create new explorations for remaining recipes (branch paths)
			for i := 1; i < len(recipes); i++ {
				recipe := recipes[i]
				
				// Clone the current exploration
				newExploration := cloneExploration(currentExploration)
				
				// Add this recipe variant
				newExploration.Path[curName] = RecipeStep{
					Combo: IngredientCombo{
						A: graph.IDToName[recipe.InputA],
						B: graph.IDToName[recipe.InputB],
					},
				}
				
				// Add ingredient elements to new path's incomplete list
				newIngredientA := graph.IDToName[recipe.InputA]
				newIngredientB := graph.IDToName[recipe.InputB]
				
				// Remove current, add ingredients if not base
				delete(newExploration.IncompletePath, curName)
				if !isBaseElement(newIngredientA) {
					newExploration.IncompletePath[newIngredientA] = true
					newExploration.Queue.PushBack(recipe.InputA)
				}
				
				if !isBaseElement(newIngredientB) {
					newExploration.IncompletePath[newIngredientB] = true
					newExploration.Queue.PushBack(recipe.InputB)
				}
				
				// Add to explorations queue for workers to pick up
				select {
				case *explorationsQueue <- newExploration:
					// Successfully queued
				default:
					// Queue is full, process this branch ourselves
					processExploration(
						newExploration, 
						reverseGraph, 
						graph, 
						completedPaths, 
						explorationsQueue, 
						enoughPaths,
						enoughPathsMutex,
						maxPaths,
					)
				}
			}
		} else if len(recipes) == 1 {
			// Just one recipe, continue current path
			recipe := recipes[0]
			
			// Add recipe to current path
			currentExploration.Path[curName] = RecipeStep{
				Combo: IngredientCombo{
					A: graph.IDToName[recipe.InputA],
					B: graph.IDToName[recipe.InputB],
				},
			}
			
			// Add ingredient elements to incomplete path
			ingredientA := graph.IDToName[recipe.InputA]
			ingredientB := graph.IDToName[recipe.InputB]
			
			// Remove current, add ingredients if not base
			delete(currentExploration.IncompletePath, curName)
			if !isBaseElement(ingredientA) {
				currentExploration.IncompletePath[ingredientA] = true
				currentExploration.Queue.PushBack(recipe.InputA)
			}
			
			if !isBaseElement(ingredientB) {
				currentExploration.IncompletePath[ingredientB] = true
				currentExploration.Queue.PushBack(recipe.InputB)
			}
		}
		
		// Check if this path is now complete (all elements resolved to base)
		if len(currentExploration.IncompletePath) == 0 {
			// Path is complete - submit to collector
			*completedPaths <- struct {
				path        map[string]RecipeStep
				searchSteps []SearchStep
				nodeCount   int
			}{
				path:        currentExploration.Path,
				searchSteps: currentExploration.SearchSteps,
				nodeCount:   currentExploration.NodeCount,
			}
			
			// Don't continue with this exploration
			break
		}
	}
}

// Helper function to build reverse graph (product -> ingredient combinations)
func buildReverseGraph(graph IndexedGraph) map[int][]struct{ InputA, InputB int } {
	reverse := make(map[int][]struct{ InputA, InputB int })
	
	// Iterate through all elements
	for elementID, neighbors := range graph.Edges {
		for _, neighbor := range neighbors {
			partnerID := neighbor.PartnerID
			productID := neighbor.ProductID
			
			// Add recipe to reverse graph
			reverse[productID] = append(reverse[productID], struct{ InputA, InputB int }{
				InputA: elementID,
				InputB: partnerID,
			})
		}
	}
	
	return reverse
}

// Clone a path exploration
func cloneExploration(original PathExploration) PathExploration {
	clone := PathExploration{
		Path:           make(map[string]RecipeStep),
		IncompletePath: make(map[string]bool),
		Queue:          list.New(),
		SearchSteps:    make([]SearchStep, len(original.SearchSteps)),
		NodeCount:      original.NodeCount,
	}
	
	// Copy path
	for k, v := range original.Path {
		clone.Path[k] = v
	}
	
	// Copy incomplete path
	for k := range original.IncompletePath {
		clone.IncompletePath[k] = true
	}
	
	// Copy queue
	for e := original.Queue.Front(); e != nil; e = e.Next() {
		clone.Queue.PushBack(e.Value)
	}
	
	// Copy search steps
	copy(clone.SearchSteps, original.SearchSteps)
	
	return clone
}

// Helper function to convert queue to slice of IDs
func queueToSlice(queue *list.List) []int {
	result := make([]int, 0, queue.Len())
	for e := queue.Front(); e != nil; e = e.Next() {
		result = append(result, e.Value.(int))
	}
	return result
}

// Helper function to convert queue to slice of names
func queueToNameSlice(queue *list.List, graph IndexedGraph) []string {
	result := make([]string, 0, queue.Len())
	for e := queue.Front(); e != nil; e = e.Next() {
		result = append(result, graph.IDToName[e.Value.(int)])
	}
	return result
}

// Create a unique hash for a path to detect duplicates
func createPathHash(path map[string]RecipeStep) string {
	// Sort keys for consistent hash
	keys := make([]string, 0, len(path))
	for k := range path {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	
	// Build hash string
	var hashBuilder strings.Builder
	for _, k := range keys {
		hashBuilder.WriteString(k)
		hashBuilder.WriteString(":")
		hashBuilder.WriteString(path[k].Combo.A)
		hashBuilder.WriteString("+")
		hashBuilder.WriteString(path[k].Combo.B)
		hashBuilder.WriteString(";")
	}
	
	return hashBuilder.String()
}

// Caller for the multithreaded BFS
func FindMultipleRecipePathsParallel(target string, maxPaths int, numWorkers int) ReversedBFSResponse {
	resp := ReversedBFSResponse{}
	
	// Determine number of workers if not specified
	if numWorkers <= 0 {
		numWorkers = 4 // Default to 4 workers
	}
	
	// Run the multi-path reversed BFS with parallelism
	pathsList, searchSteps, nodesVisited := ReversedMultiPathBFSParallel(target, GlobalIndexedGraph, maxPaths, numWorkers)
	
	// Fill response
	resp.Target = target
	resp.NodesVisited = nodesVisited
	resp.SearchSteps = searchSteps
	resp.PathsCount = len(pathsList)
	
	// Convert each path to a recipe tree
	resp.RecipeTrees = make([]RecipeTree, 0, len(pathsList))
	for _, path := range pathsList {
		// Convert ProductToIngredients path to a tree structure
		tree := BuildTreeFromPath(target, path)
		resp.RecipeTrees = append(resp.RecipeTrees, tree)
	}
	
	return resp
}

// Response structure for reversed multi-path BFS
type ReversedBFSResponse struct {
	Target       string       `json:"target"`
	NodesVisited int          `json:"nodesVisited"`
	PathsCount   int          `json:"pathsCount"`
	RecipeTrees  []RecipeTree `json:"recipeTrees"`
	SearchSteps  []SearchStep `json:"searchSteps"`
}

// Build a tree from a path returned by the reversed BFS
func BuildTreeFromPath(target string, path ProductToIngredients) RecipeTree {
	tree := RecipeTree{
		Element: target,
	}
	
	// Recursively build the tree
	buildTreeRecursive(&tree, path)
	
	return tree
}

// Recursively build a tree from a path
func buildTreeRecursive(node *RecipeTree, path ProductToIngredients) {
	// Check if this element has ingredients in the path
	if recipeStep, exists := path[node.Element]; exists {
		// Create child nodes for ingredients
		ingredientA := recipeStep.Combo.A
		ingredientB := recipeStep.Combo.B
		
		// Add children
		node.Children = []RecipeTree{
			{Element: ingredientA},
			{Element: ingredientB},
		}
		
		// Continue recursively building the tree for non-base elements
		if !isBaseElement(ingredientA) {
			buildTreeRecursive(&node.Children[0], path)
		}
		
		if !isBaseElement(ingredientB) {
			buildTreeRecursive(&node.Children[1], path)
		}
	}
}